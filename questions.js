Q1.A) Function countRoles(users) {
   const user={};
   return user.filter(countRoles.user)=>[user(countRoles.user)||0,1]
   console.log(countRoles(users))
   }

B) Function countRoles(str){
   while (countRoles.length===0) return 0
  return user
  .filter(countRoles.user)=>[user.countRoles.user)
    .map(user.name)
    const user=[
    {name:'alice', roles:'admin'}
    {name:'bora', roles:'student'}
    {name:'tina', roles:'instructor'}
  {name:'fina', roles:'student'}
  {name:'bobo', roles:'student'}
  {names:'bob', roles:'admin'}
   {name:'keza', roles:'student'}
  {name:'winnie', roles:'student'}
  console.log(countRoles(str)
              }
C) Function findAdmins(users){
   return user.filter(!array.isarray(roles.name==='admin'))
                                     }
D) Function findAdmins(users){
  if(roles.length===0) return'No admins found'
   return user
  .filter(countRoles.user)=>[user(countRoles.user)
    .map(user.name)
     console.log(findAdmins(user));
   }
E) Function generateWelcomeMessagea(users){
   return user.filter('Welcome',${user.name}!you are an, ${user.roles}
   }
F) Function generateWelcomeMessagea(users){
   return user.map('Welcome',${user.name}!you are an, ${user.roles}
  }
G) The advantages of using array methods (map, filter) over traditional loops in this
scenario it is because :
it makes the codes more clear and concise which is also reduce high risks of errors

Q2. A) Function sumDigits(n){
    while(n===0) return0 {
   return acc.n=>(acc.n||0,1)

 B) Function power(base,exponent){
     while(power===0) return 1;
     else
     return power*base(base,exponent-1)
  }
   C) Function reverseWords(sentence){
      let words===sentence;
      if(sentence.length===0) return 'sentence'
      else
         return (sentence-1 + " " +reverseWords(sentence)
                 }
   D) Recursion is less efficient when recursion depth is too large.
      Iteration would be better choice while calculating fibonacci of large number
    
   E) function sumDigits(n){
      let sum===0;
      if(n===0){
         return0;
      else 
         sum=n%10
         n=math.floor(n/10)
   console.log(sumDigits(n))
   }}
comparison is that recursion become weak in calculating large number

   
Q3. A) Function findTopScores(student,threshold){
      const maxscores={};
   maxscores=(countscore.student=>[(countscore.student)||0,1]
        return student.filter(student.score>countscore?studen.score:countscore
                              return(maxscores)
      }

  B) Function sortStudentByScore(students){
     return student.filter(student.score=sort(scores)
             .map(students.name)
                         }

 C) Function removeDuplicate(arr){
    if (!array.isarray(student.score=>arr.score))
   console.log(removeDuplicate(arr))
    }

 D ) Function getMediamScore(scores){
     student.arr=maxscore/minscore;
    return arr[maxscore/minscore];
    }

 E)  Sorting affect performance becouase it produce the output in the way you want it.
      and it perform faster


Q4.  A) Function groupBooksByAurthor(books){
     const books={};
     books=books.name group by books.aurthor
    return books
     }

   B) Function findBookPublishedAfter(books,year){
      if(year.length<=given year) return'there is no book published after this year'
      else
         return book.name;
       }
   C)


















   
         
   

























